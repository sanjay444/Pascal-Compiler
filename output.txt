 #    2
 #    3
 #    4
 #    5
 #    6
 #    7
 #    8
entering process_var_decl()
				# b_global_decl (K, alignment = 4, size = 4)
.globl K
	.data
	.align	4
	.type	K, @object
	.size	K, 4
K:
	.zero	4
				# b_global_decl (J, alignment = 4, size = 4)
.globl J
	.align	4
	.type	J, @object
	.size	J, 4
J:
	.zero	4
				# b_global_decl (I, alignment = 4, size = 4)
.globl I
	.align	4
	.type	I, @object
	.size	I, 4
I:
	.zero	4
exiting process_var_decl()
 #    9
entering process_var_decl()
				# b_global_decl (Z, alignment = 4, size = 4)
.globl Z
	.align	4
	.type	Z, @object
	.size	Z, 4
Z:
	.zero	4
				# b_global_decl (Y, alignment = 4, size = 4)
.globl Y
	.align	4
	.type	Y, @object
	.size	Y, 4
Y:
	.zero	4
				# b_global_decl (X, alignment = 4, size = 4)
.globl X
	.align	4
	.type	X, @object
	.size	X, 4
X:
	.zero	4
exiting process_var_decl()
 #   10
entering process_var_decl()
				# b_global_decl (C, alignment = 1, size = 1)
.globl C
	.align	1
	.type	C, @object
	.size	C, 1
C:
	.zero	1
exiting process_var_decl()
 #   11
entering process_var_decl()
				# b_global_decl (D, alignment = 8, size = 8)
.globl D
	.align	8
	.type	D, @object
	.size	D, 8
D:
	.zero	8
exiting process_var_decl()
 #   12
entering process_var_decl()
				# b_global_decl (B, alignment = 1, size = 1)
.globl B
	.align	1
	.type	B, @object
	.size	B, 1
B:
	.zero	1
exiting process_var_decl()
 #   13
 #   14
 #   15
 #   16
entering build_func_decl()
exiting build_func_decl()
 #   17
 #   18
entering build_func_decl()
exiting build_func_decl()
 #   19
 #   20
entering build_func_decl()
exiting build_func_decl()
				# b_func_prologue (main)
	.text
.global main
	.type	main, @function
main:
	pushl	%ebp
	movl	%esp, %ebp
	andl	$-16, %esp
 #   21
 #   22
entering make_id_expr() for id "I"
new node is a gdecl
exiting make_id_expr()
making intconst
entering check_assign_or_proc_call()
rhs not null
creating an assignment op
creating a binary expression/ntype is not tyfunc or tyerror, return true
otherwise we return false
performing unary conversion on left and right
type is not tyfunc or tyerror, return true
performing binary conversion left and right
Binary expr: types are matches
exiting make binary express()
				# b_push_ext_addr (I)
	subl	$8, %esp
	movl	$I, (%esp)
				# b_push_const_int (5)
	movl	$5, %eax
	subl	$8, %esp
	movl	%eax, (%esp)
				# b_assign (signed long int)
	movl	(%esp), %edx
	addl	$8, %esp
	movl	(%esp), %eax
	movl	%edx, (%eax)
	movl	%edx, (%esp)
				# b_pop ()
	addl	$8, %esp
 #   23
entering make_id_expr() for id "J"
new node is a gdecl
exiting make_id_expr()
entering make_id_expr() for id "I"
new node is a gdecl
exiting make_id_expr()
entering check_assign_or_proc_call()
rhs not null
creating an assignment op
creating a binary expression/ntype is not tyfunc or tyerror, return true
type is not tyfunc or tyerror, return true
make_bin: creating deref node because right side l-val
entering make_un_expr()
performing unary conversion on left and right
type is not tyfunc or tyerror, return true
performing binary conversion left and right
Binary expr: types are matches
exiting make binary express()
				# b_push_ext_addr (J)
	subl	$8, %esp
	movl	$J, (%esp)
				# b_push_ext_addr (I)
	subl	$8, %esp
	movl	$I, (%esp)
				# b_deref (signed long int)
	movl	(%esp), %eax
	movl	(%eax), %edx
	movl	%edx, (%esp)
				# b_assign (signed long int)
	movl	(%esp), %edx
	addl	$8, %esp
	movl	(%esp), %eax
	movl	%edx, (%eax)
	movl	%edx, (%esp)
				# b_pop ()
	addl	$8, %esp
 #   24
entering make_id_expr() for id "K"
new node is a gdecl
exiting make_id_expr()
making intconst
entering check_assign_or_proc_call()
rhs not null
creating an assignment op
creating a binary expression/ntype is not tyfunc or tyerror, return true
otherwise we return false
performing unary conversion on left and right
type is not tyfunc or tyerror, return true
performing binary conversion left and right
Binary expr: types are matches
exiting make binary express()
				# b_push_ext_addr (K)
	subl	$8, %esp
	movl	$K, (%esp)
				# b_push_const_int (14)
	movl	$14, %eax
	subl	$8, %esp
	movl	%eax, (%esp)
				# b_assign (signed long int)
	movl	(%esp), %edx
	addl	$8, %esp
	movl	(%esp), %eax
	movl	%edx, (%eax)
	movl	%edx, (%esp)
				# b_pop ()
	addl	$8, %esp
 #   25
entering make_id_expr() for id "X"
new node is a gdecl
exiting make_id_expr()
making realconst
entering check_assign_or_proc_call()
rhs not null
creating an assignment op
creating a binary expression/ntype is not tyfunc or tyerror, return true
otherwise we return false
performing unary conversion on left and right
type is not tyfunc or tyerror, return true
performing binary conversion left and right
exiting make binary express()
				# b_push_ext_addr (X)
	subl	$8, %esp
	movl	$X, (%esp)
				# b_push_const_double (3.1400000000000001e+00)
	.section	.rodata
	.align	8
.LC0:
	.long	1374389535
	.long	1074339512
	.text
	fldl	.LC0
	subl	$8, %esp
	fstpl	(%esp)
b_convert of assign ops
				# b_convert (double -> float)
	fldl	(%esp)
	fstps	(%esp)
				# b_assign (float)
	movl	(%esp), %edx
	addl	$8, %esp
	movl	(%esp), %eax
	movl	%edx, (%eax)
	movl	%edx, (%esp)
				# b_pop ()
	addl	$8, %esp
 #   26
entering make_id_expr() for id "Y"
new node is a gdecl
exiting make_id_expr()
making realconst
entering check_assign_or_proc_call()
rhs not null
creating an assignment op
creating a binary expression/ntype is not tyfunc or tyerror, return true
otherwise we return false
performing unary conversion on left and right
type is not tyfunc or tyerror, return true
performing binary conversion left and right
exiting make binary express()
				# b_push_ext_addr (Y)
	subl	$8, %esp
	movl	$Y, (%esp)
				# b_push_const_double (2.7100000000000000e+00)
	.section	.rodata
	.align	8
.LC1:
	.long	2061584302
	.long	1074114068
	.text
	fldl	.LC1
	subl	$8, %esp
	fstpl	(%esp)
b_convert of assign ops
				# b_convert (double -> float)
	fldl	(%esp)
	fstps	(%esp)
				# b_assign (float)
	movl	(%esp), %edx
	addl	$8, %esp
	movl	(%esp), %eax
	movl	%edx, (%eax)
	movl	%edx, (%esp)
				# b_pop ()
	addl	$8, %esp
 #   27
entering make_id_expr() for id "Z"
new node is a gdecl
exiting make_id_expr()
making realconst
entering check_assign_or_proc_call()
rhs not null
creating an assignment op
creating a binary expression/ntype is not tyfunc or tyerror, return true
otherwise we return false
performing unary conversion on left and right
type is not tyfunc or tyerror, return true
performing binary conversion left and right
exiting make binary express()
				# b_push_ext_addr (Z)
	subl	$8, %esp
	movl	$Z, (%esp)
				# b_push_const_double (0.0000000000000000e+00)
	.section	.rodata
	.align	8
.LC2:
	.long	0
	.long	0
	.text
	fldl	.LC2
	subl	$8, %esp
	fstpl	(%esp)
b_convert of assign ops
				# b_convert (double -> float)
	fldl	(%esp)
	fstps	(%esp)
				# b_assign (float)
	movl	(%esp), %edx
	addl	$8, %esp
	movl	(%esp), %eax
	movl	%edx, (%eax)
	movl	%edx, (%esp)
				# b_pop ()
	addl	$8, %esp
 #   28
entering make_id_expr() for id "D"
new node is a gdecl
exiting make_id_expr()
making realconst
entering check_assign_or_proc_call()
rhs not null
creating an assignment op
creating a binary expression/ntype is not tyfunc or tyerror, return true
otherwise we return false
performing unary conversion on left and right
type is not tyfunc or tyerror, return true
performing binary conversion left and right
Binary expr: types are matches
exiting make binary express()
				# b_push_ext_addr (D)
	subl	$8, %esp
	movl	$D, (%esp)
				# b_push_const_double (1.9199900000000000e+01)
	.section	.rodata
	.align	8
.LC3:
	.long	-1518700436
	.long	1077097260
	.text
	fldl	.LC3
	subl	$8, %esp
	fstpl	(%esp)
				# b_assign (double)
	fldl	(%esp)
	addl	$8, %esp
	movl	(%esp), %eax
	fstpl	(%eax)
	fstpl	(%esp)
				# b_pop ()
	addl	$8, %esp
 #   29
entering make_id_expr() for id "B"
new node is a gdecl
exiting make_id_expr()
making intconst
entering check_assign_or_proc_call()
rhs not null
creating an assignment op
creating a binary expression/ntype is not tyfunc or tyerror, return true
otherwise we return false
performing unary conversion on left and right
type is not tyfunc or tyerror, return true
performing binary conversion left and right
exiting make binary express()
				# b_push_ext_addr (B)
	subl	$8, %esp
	movl	$B, (%esp)
				# b_push_const_int (0)
	movl	$0, %eax
	subl	$8, %esp
	movl	%eax, (%esp)
b_convert of assign ops
				# b_convert (signed long int -> signed char)
				# b_assign (signed char)
	movzbl	(%esp), %edx
	addl	$8, %esp
	movl	(%esp), %eax
	movb	%dl, (%eax)
	movb	%dl, (%esp)
				# b_pop ()
	addl	$8, %esp
 #   30
entering make_id_expr() for id "C"
new node is a gdecl
exiting make_id_expr()
making intconst
entering make_un_expr()
otherwise we return false
otherwise we return false
exiting make_un_expr()
entering check_assign_or_proc_call()
rhs not null
creating an assignment op
creating a binary expression/ntype is not tyfunc or tyerror, return true
performing unary conversion on left and right
type is not tyfunc or tyerror, return true
performing binary conversion left and right
Binary expr: types are matches
exiting make binary express()
				# b_push_ext_addr (C)
	subl	$8, %esp
	movl	$C, (%esp)
				# b_push_const_int (65)
	movl	$65, %eax
	subl	$8, %esp
	movl	%eax, (%esp)
				# b_convert (signed long int -> unsigned char)
				# b_assign (unsigned char)
	movzbl	(%esp), %edx
	addl	$8, %esp
	movl	(%esp), %eax
	movb	%dl, (%eax)
	movb	%dl, (%esp)
				# b_pop ()
	addl	$8, %esp
 #   31
 #   32
entering make_id_expr() for id "Print_globals"
new node is a gdecl
exiting make_id_expr()
entering check_assign_or_proc_call()
rhs is null
rhs should be null and lhs is tag GID
entering make_fcall_expr()
yes it equals tyvoid/nexternal function....
exiting make_fcall_expr()
				# b_alloc_arglist (0 bytes)
	movl	%esp, %eax
	subl	$4, %esp
	andl	$-16, %esp
	movl	%eax, (%esp)
	subl	$0, %esp
				# b_funcall_by_name (Print_globals, void)
	call	Print_globals
	addl	$0, %esp
	movl	(%esp), %ecx
	movl	%ecx, %esp
 #   33
 #   34
entering make_id_expr() for id "K"
new node is a gdecl
exiting make_id_expr()
entering make_id_expr() for id "I"
new node is a gdecl
exiting make_id_expr()
entering make_id_expr() for id "J"
new node is a gdecl
exiting make_id_expr()
creating a binary expression/ntype is not tyfunc or tyerror, return true
creating a deref node becuase left side l-val and not assign op
entering make_un_expr()
type is not tyfunc or tyerror, return true
make_bin: creating deref node because right side l-val
entering make_un_expr()
performing unary conversion on left and right
type is not tyfunc or tyerror, return true
performing binary conversion left and right
Binary expr: types are matches
exiting make binary express()
entering check_assign_or_proc_call()
rhs not null
creating an assignment op
creating a binary expression/ntype is not tyfunc or tyerror, return true
otherwise we return false
performing unary conversion on left and right
type is not tyfunc or tyerror, return true
performing binary conversion left and right
Binary expr: types are matches
exiting make binary express()
				# b_push_ext_addr (K)
	subl	$8, %esp
	movl	$K, (%esp)
				# b_push_ext_addr (I)
	subl	$8, %esp
	movl	$I, (%esp)
				# b_deref (signed long int)
	movl	(%esp), %eax
	movl	(%eax), %edx
	movl	%edx, (%esp)
				# b_push_ext_addr (J)
	subl	$8, %esp
	movl	$J, (%esp)
				# b_deref (signed long int)
	movl	(%esp), %eax
	movl	(%eax), %edx
	movl	%edx, (%esp)
				# b_arith_rel_op ( + , signed long int)
	movl	(%esp), %ecx
	addl	$8, %esp
	movl	(%esp), %eax
	addl	%ecx, %eax
	movl	%eax, (%esp)
				# b_assign (signed long int)
	movl	(%esp), %edx
	addl	$8, %esp
	movl	(%esp), %eax
	movl	%edx, (%eax)
	movl	%edx, (%esp)
				# b_pop ()
	addl	$8, %esp
 #   35
entering make_id_expr() for id "J"
new node is a gdecl
exiting make_id_expr()
entering make_id_expr() for id "I"
new node is a gdecl
exiting make_id_expr()
entering make_id_expr() for id "K"
new node is a gdecl
exiting make_id_expr()
entering make_id_expr() for id "K"
new node is a gdecl
exiting make_id_expr()
creating a binary expression/ntype is not tyfunc or tyerror, return true
creating a deref node becuase left side l-val and not assign op
entering make_un_expr()
type is not tyfunc or tyerror, return true
make_bin: creating deref node because right side l-val
entering make_un_expr()
performing unary conversion on left and right
type is not tyfunc or tyerror, return true
performing binary conversion left and right
Binary expr: types are matches
exiting make binary express()
entering make_id_expr() for id "I"
new node is a gdecl
exiting make_id_expr()
entering make_id_expr() for id "K"
new node is a gdecl
exiting make_id_expr()
creating a binary expression/ntype is not tyfunc or tyerror, return true
creating a deref node becuase left side l-val and not assign op
entering make_un_expr()
type is not tyfunc or tyerror, return true
make_bin: creating deref node because right side l-val
entering make_un_expr()
performing unary conversion on left and right
type is not tyfunc or tyerror, return true
performing binary conversion left and right
Binary expr: types are matches
exiting make binary express()
creating a binary expression/notherwise we return false
otherwise we return false
performing unary conversion on left and right
otherwise we return false
performing binary conversion left and right
Binary expr: types are matches
exiting make binary express()
creating a binary expression/ntype is not tyfunc or tyerror, return true
creating a deref node becuase left side l-val and not assign op
entering make_un_expr()
otherwise we return false
performing unary conversion on left and right
type is not tyfunc or tyerror, return true
performing binary conversion left and right
Binary expr: types are matches
exiting make binary express()
entering check_assign_or_proc_call()
rhs not null
creating an assignment op
creating a binary expression/ntype is not tyfunc or tyerror, return true
otherwise we return false
performing unary conversion on left and right
type is not tyfunc or tyerror, return true
performing binary conversion left and right
Binary expr: types are matches
exiting make binary express()
				# b_push_ext_addr (J)
	subl	$8, %esp
	movl	$J, (%esp)
				# b_push_ext_addr (I)
	subl	$8, %esp
	movl	$I, (%esp)
				# b_deref (signed long int)
	movl	(%esp), %eax
	movl	(%eax), %edx
	movl	%edx, (%esp)
				# b_push_ext_addr (K)
	subl	$8, %esp
	movl	$K, (%esp)
				# b_deref (signed long int)
	movl	(%esp), %eax
	movl	(%eax), %edx
	movl	%edx, (%esp)
				# b_push_ext_addr (K)
	subl	$8, %esp
	movl	$K, (%esp)
				# b_deref (signed long int)
	movl	(%esp), %eax
	movl	(%eax), %edx
	movl	%edx, (%esp)
				# b_arith_rel_op ( * , signed long int)
	movl	(%esp), %ecx
	addl	$8, %esp
	movl	(%esp), %eax
	imull	%ecx, %eax
	movl	%eax, (%esp)
				# b_push_ext_addr (I)
	subl	$8, %esp
	movl	$I, (%esp)
				# b_deref (signed long int)
	movl	(%esp), %eax
	movl	(%eax), %edx
	movl	%edx, (%esp)
				# b_push_ext_addr (K)
	subl	$8, %esp
	movl	$K, (%esp)
				# b_deref (signed long int)
	movl	(%esp), %eax
	movl	(%eax), %edx
	movl	%edx, (%esp)
				# b_arith_rel_op ( + , signed long int)
	movl	(%esp), %ecx
	addl	$8, %esp
	movl	(%esp), %eax
	addl	%ecx, %eax
	movl	%eax, (%esp)
				# b_arith_rel_op ( / , signed long int)
	movl	(%esp), %ecx
	addl	$8, %esp
	movl	(%esp), %eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	movl	%eax, (%esp)
				# b_arith_rel_op ( - , signed long int)
	movl	(%esp), %ecx
	addl	$8, %esp
	movl	(%esp), %eax
	subl	%ecx, %eax
	movl	%eax, (%esp)
				# b_assign (signed long int)
	movl	(%esp), %edx
	addl	$8, %esp
	movl	(%esp), %eax
	movl	%edx, (%eax)
	movl	%edx, (%esp)
				# b_pop ()
	addl	$8, %esp
 #   36
entering make_id_expr() for id "I"
new node is a gdecl
exiting make_id_expr()
entering make_id_expr() for id "K"
new node is a gdecl
exiting make_id_expr()
making intconst
creating a binary expression/ntype is not tyfunc or tyerror, return true
creating a deref node becuase left side l-val and not assign op
entering make_un_expr()
otherwise we return false
performing unary conversion on left and right
type is not tyfunc or tyerror, return true
performing binary conversion left and right
Binary expr: types are matches
exiting make binary express()
entering check_assign_or_proc_call()
rhs not null
creating an assignment op
creating a binary expression/ntype is not tyfunc or tyerror, return true
otherwise we return false
performing unary conversion on left and right
type is not tyfunc or tyerror, return true
performing binary conversion left and right
Binary expr: types are matches
exiting make binary express()
				# b_push_ext_addr (I)
	subl	$8, %esp
	movl	$I, (%esp)
				# b_push_ext_addr (K)
	subl	$8, %esp
	movl	$K, (%esp)
				# b_deref (signed long int)
	movl	(%esp), %eax
	movl	(%eax), %edx
	movl	%edx, (%esp)
				# b_push_const_int (7)
	movl	$7, %eax
	subl	$8, %esp
	movl	%eax, (%esp)
				# b_arith_rel_op ( % , signed long int)
	movl	(%esp), %ecx
	addl	$8, %esp
	movl	(%esp), %eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	movl	%edx, (%esp)
				# b_assign (signed long int)
	movl	(%esp), %edx
	addl	$8, %esp
	movl	(%esp), %eax
	movl	%edx, (%eax)
	movl	%edx, (%esp)
				# b_pop ()
	addl	$8, %esp
 #   37
entering make_id_expr() for id "B"
new node is a gdecl
exiting make_id_expr()
entering make_id_expr() for id "K"
new node is a gdecl
exiting make_id_expr()
entering make_id_expr() for id "J"
new node is a gdecl
exiting make_id_expr()
creating a binary expression/ntype is not tyfunc or tyerror, return true
creating a deref node becuase left side l-val and not assign op
entering make_un_expr()
type is not tyfunc or tyerror, return true
make_bin: creating deref node because right side l-val
entering make_un_expr()
performing unary conversion on left and right
type is not tyfunc or tyerror, return true
performing binary conversion left and right
Binary expr: types are matches
exiting make binary express()
entering check_assign_or_proc_call()
rhs not null
creating an assignment op
creating a binary expression/ntype is not tyfunc or tyerror, return true
otherwise we return false
performing unary conversion on left and right
type is not tyfunc or tyerror, return true
performing binary conversion left and right
exiting make binary express()
				# b_push_ext_addr (B)
	subl	$8, %esp
	movl	$B, (%esp)
				# b_push_ext_addr (K)
	subl	$8, %esp
	movl	$K, (%esp)
				# b_deref (signed long int)
	movl	(%esp), %eax
	movl	(%eax), %edx
	movl	%edx, (%esp)
				# b_push_ext_addr (J)
	subl	$8, %esp
	movl	$J, (%esp)
				# b_deref (signed long int)
	movl	(%esp), %eax
	movl	(%eax), %edx
	movl	%edx, (%esp)
				# b_arith_rel_op ( > , signed long int)
	movl	(%esp), %ecx
	addl	$8, %esp
	movl	(%esp), %eax
	cmpl	%ecx, %eax
	setg	%al
	movzbl	%al, %eax
	movl	%eax, (%esp)
b_convert of assign ops
				# b_convert (signed long int -> signed char)
				# b_assign (signed char)
	movzbl	(%esp), %edx
	addl	$8, %esp
	movl	(%esp), %eax
	movb	%dl, (%eax)
	movb	%dl, (%esp)
				# b_pop ()
	addl	$8, %esp
 #   38
entering make_id_expr() for id "C"
new node is a gdecl
exiting make_id_expr()
entering make_id_expr() for id "C"
new node is a gdecl
exiting make_id_expr()
entering make_un_expr()
type is not tyfunc or tyerror, return true
id string C
creating DEREF node
entering make_un_expr()
type is not tyfunc or tyerror, return true
exiting make_un_expr()
entering check_assign_or_proc_call()
rhs not null
creating an assignment op
creating a binary expression/ntype is not tyfunc or tyerror, return true
performing unary conversion on left and right
type is not tyfunc or tyerror, return true
performing binary conversion left and right
Binary expr: types are matches
exiting make binary express()
				# b_push_ext_addr (C)
	subl	$8, %esp
	movl	$C, (%esp)
				# b_push_ext_addr (C)
	subl	$8, %esp
	movl	$C, (%esp)
				# b_deref (unsigned char)
	movl	(%esp), %eax
	movzbl	(%eax), %edx
	movb	%dl, (%esp)
				# b_convert (unsigned char -> signed long int)
	movzbl	(%esp), %eax
	movzbl	%al, %eax
	movl	%eax, (%esp)
				# b_push_const_int (1)
	movl	$1, %eax
	subl	$8, %esp
	movl	%eax, (%esp)
				# b_arith_rel_op ( + , signed long int)
	movl	(%esp), %ecx
	addl	$8, %esp
	movl	(%esp), %eax
	addl	%ecx, %eax
	movl	%eax, (%esp)
				# b_convert (signed long int -> unsigned char)
				# b_assign (unsigned char)
	movzbl	(%esp), %edx
	addl	$8, %esp
	movl	(%esp), %eax
	movb	%dl, (%eax)
	movb	%dl, (%esp)
				# b_pop ()
	addl	$8, %esp
 #   39
 #   40
entering make_id_expr() for id "Print_globals"
new node is a gdecl
exiting make_id_expr()
entering check_assign_or_proc_call()
rhs is null
rhs should be null and lhs is tag GID
entering make_fcall_expr()
yes it equals tyvoid/nexternal function....
exiting make_fcall_expr()
				# b_alloc_arglist (0 bytes)
	movl	%esp, %eax
	subl	$4, %esp
	andl	$-16, %esp
	movl	%eax, (%esp)
	subl	$0, %esp
				# b_funcall_by_name (Print_globals, void)
	call	Print_globals
	addl	$0, %esp
	movl	(%esp), %ecx
	movl	%ecx, %esp
 #   41
 #   42
entering make_id_expr() for id "Y"
new node is a gdecl
exiting make_id_expr()
entering make_id_expr() for id "K"
new node is a gdecl
exiting make_id_expr()
entering check_assign_or_proc_call()
rhs not null
creating an assignment op
creating a binary expression/ntype is not tyfunc or tyerror, return true
type is not tyfunc or tyerror, return true
make_bin: creating deref node because right side l-val
entering make_un_expr()
performing unary conversion on left and right
type is not tyfunc or tyerror, return true
performing binary conversion left and right
exiting make binary express()
				# b_push_ext_addr (Y)
	subl	$8, %esp
	movl	$Y, (%esp)
				# b_push_ext_addr (K)
	subl	$8, %esp
	movl	$K, (%esp)
				# b_deref (signed long int)
	movl	(%esp), %eax
	movl	(%eax), %edx
	movl	%edx, (%esp)
b_convert of assign ops
				# b_convert (signed long int -> float)
	fildl	(%esp)
	fstps	(%esp)
				# b_assign (float)
	movl	(%esp), %edx
	addl	$8, %esp
	movl	(%esp), %eax
	movl	%edx, (%eax)
	movl	%edx, (%esp)
				# b_pop ()
	addl	$8, %esp
 #   43
entering make_id_expr() for id "X"
new node is a gdecl
exiting make_id_expr()
entering make_id_expr() for id "Y"
new node is a gdecl
exiting make_id_expr()
entering check_assign_or_proc_call()
rhs not null
creating an assignment op
creating a binary expression/ntype is not tyfunc or tyerror, return true
type is not tyfunc or tyerror, return true
make_bin: creating deref node because right side l-val
entering make_un_expr()
performing unary conversion on left and right
type is not tyfunc or tyerror, return true
performing binary conversion left and right
Binary expr: types are matches
exiting make binary express()
				# b_push_ext_addr (X)
	subl	$8, %esp
	movl	$X, (%esp)
				# b_push_ext_addr (Y)
	subl	$8, %esp
	movl	$Y, (%esp)
				# b_deref (float)
	movl	(%esp), %eax
	movl	(%eax), %edx
	movl	%edx, (%esp)
				# b_assign (float)
	movl	(%esp), %edx
	addl	$8, %esp
	movl	(%esp), %eax
	movl	%edx, (%eax)
	movl	%edx, (%esp)
				# b_pop ()
	addl	$8, %esp
 #   44
entering make_id_expr() for id "D"
new node is a gdecl
exiting make_id_expr()
entering make_id_expr() for id "K"
new node is a gdecl
exiting make_id_expr()
entering check_assign_or_proc_call()
rhs not null
creating an assignment op
creating a binary expression/ntype is not tyfunc or tyerror, return true
type is not tyfunc or tyerror, return true
make_bin: creating deref node because right side l-val
entering make_un_expr()
performing unary conversion on left and right
type is not tyfunc or tyerror, return true
performing binary conversion left and right
entering make_un_expr()
type is not tyfunc or tyerror, return true
id string K
creating DEREF node
entering make_un_expr()
type is not tyfunc or tyerror, return true
exiting make_un_expr()
Binary expr: types are matches
exiting make binary express()
				# b_push_ext_addr (D)
	subl	$8, %esp
	movl	$D, (%esp)
				# b_push_ext_addr (K)
	subl	$8, %esp
	movl	$K, (%esp)
				# b_deref (signed long int)
	movl	(%esp), %eax
	movl	(%eax), %edx
	movl	%edx, (%esp)
				# b_convert (signed long int -> double)
	fildl	(%esp)
	fstpl	(%esp)
				# b_assign (double)
	fldl	(%esp)
	addl	$8, %esp
	movl	(%esp), %eax
	fstpl	(%eax)
	fstpl	(%esp)
				# b_pop ()
	addl	$8, %esp
 #   45
entering make_id_expr() for id "C"
new node is a gdecl
exiting make_id_expr()
entering make_id_expr() for id "K"
new node is a gdecl
exiting make_id_expr()
entering make_un_expr()
type is not tyfunc or tyerror, return true
id string K
creating DEREF node
entering make_un_expr()
type is not tyfunc or tyerror, return true
exiting make_un_expr()
entering make_un_expr()
exiting make_un_expr()
entering check_assign_or_proc_call()
rhs not null
creating an assignment op
creating a binary expression/ntype is not tyfunc or tyerror, return true
performing unary conversion on left and right
type is not tyfunc or tyerror, return true
performing binary conversion left and right
Binary expr: types are matches
exiting make binary express()
				# b_push_ext_addr (C)
	subl	$8, %esp
	movl	$C, (%esp)
				# b_push_ext_addr (K)
	subl	$8, %esp
	movl	$K, (%esp)
				# b_deref (signed long int)
	movl	(%esp), %eax
	movl	(%eax), %edx
	movl	%edx, (%esp)
				# b_convert (signed long int -> unsigned char)
				# b_convert (unsigned char -> signed long int)
	movzbl	(%esp), %eax
	movzbl	%al, %eax
	movl	%eax, (%esp)
				# b_push_const_int (-1)
	movl	$-1, %eax
	subl	$8, %esp
	movl	%eax, (%esp)
				# b_arith_rel_op ( + , signed long int)
	movl	(%esp), %ecx
	addl	$8, %esp
	movl	(%esp), %eax
	addl	%ecx, %eax
	movl	%eax, (%esp)
				# b_convert (signed long int -> unsigned char)
				# b_assign (unsigned char)
	movzbl	(%esp), %edx
	addl	$8, %esp
	movl	(%esp), %eax
	movb	%dl, (%eax)
	movb	%dl, (%esp)
				# b_pop ()
	addl	$8, %esp
 #   46
entering make_id_expr() for id "Z"
new node is a gdecl
exiting make_id_expr()
entering make_id_expr() for id "C"
new node is a gdecl
exiting make_id_expr()
entering make_un_expr()
type is not tyfunc or tyerror, return true
id string C
creating DEREF node
entering make_un_expr()
type is not tyfunc or tyerror, return true
exiting make_un_expr()
entering make_id_expr() for id "I"
new node is a gdecl
exiting make_id_expr()
creating a binary expression/ntype is not tyfunc or tyerror, return true
make_bin: creating deref node because right side l-val
entering make_un_expr()
performing unary conversion on left and right
performing binary conversion left and right
Binary expr: types are matches
exiting make binary express()
entering make_id_expr() for id "D"
new node is a gdecl
exiting make_id_expr()
entering make_un_expr()
type is not tyfunc or tyerror, return true
id string D
creating DEREF node
entering make_un_expr()
type is not tyfunc or tyerror, return true
exiting make_un_expr()
creating a binary expression/notherwise we return false
performing unary conversion on left and right
otherwise we return false
performing binary conversion left and right
entering make_un_expr()
otherwise we return false
otherwise we return false
exiting make_un_expr()
Binary expr: types are matches
exiting make binary express()
entering make_id_expr() for id "X"
new node is a gdecl
exiting make_id_expr()
creating a binary expression/notherwise we return false
type is not tyfunc or tyerror, return true
make_bin: creating deref node because right side l-val
entering make_un_expr()
performing unary conversion on left and right
otherwise we return false
entering make_un_expr()
type is not tyfunc or tyerror, return true
id string X
creating DEREF node
entering make_un_expr()
type is not tyfunc or tyerror, return true
exiting make_un_expr()
performing binary conversion left and right
entering make_un_expr()
otherwise we return false
otherwise we return false
exiting make_un_expr()
Binary expr: types are matches
exiting make binary express()
entering check_assign_or_proc_call()
rhs not null
creating an assignment op
creating a binary expression/ntype is not tyfunc or tyerror, return true
otherwise we return false
performing unary conversion on left and right
type is not tyfunc or tyerror, return true
performing binary conversion left and right
exiting make binary express()
				# b_push_ext_addr (Z)
	subl	$8, %esp
	movl	$Z, (%esp)
				# b_push_ext_addr (C)
	subl	$8, %esp
	movl	$C, (%esp)
				# b_deref (unsigned char)
	movl	(%esp), %eax
	movzbl	(%eax), %edx
	movb	%dl, (%esp)
				# b_convert (unsigned char -> signed long int)
	movzbl	(%esp), %eax
	movzbl	%al, %eax
	movl	%eax, (%esp)
				# b_push_ext_addr (I)
	subl	$8, %esp
	movl	$I, (%esp)
				# b_deref (signed long int)
	movl	(%esp), %eax
	movl	(%eax), %edx
	movl	%edx, (%esp)
				# b_arith_rel_op ( * , signed long int)
	movl	(%esp), %ecx
	addl	$8, %esp
	movl	(%esp), %eax
	imull	%ecx, %eax
	movl	%eax, (%esp)
				# b_convert (signed long int -> double)
	fildl	(%esp)
	fstpl	(%esp)
				# b_push_ext_addr (D)
	subl	$8, %esp
	movl	$D, (%esp)
				# b_deref (double)
	movl	(%esp), %eax
	fldl	(%eax)
	fstpl	(%esp)
				# b_negate (double)
	fldl	(%esp)
	fchs
	fstpl	(%esp)
				# b_arith_rel_op ( + , signed long int)
	movl	(%esp), %ecx
	addl	$8, %esp
	movl	(%esp), %eax
	addl	%ecx, %eax
	movl	%eax, (%esp)
				# b_convert (signed long int -> double)
	fildl	(%esp)
	fstpl	(%esp)
				# b_push_ext_addr (X)
	subl	$8, %esp
	movl	$X, (%esp)
				# b_deref (float)
	movl	(%esp), %eax
	movl	(%eax), %edx
	movl	%edx, (%esp)
				# b_convert (float -> double)
	flds	(%esp)
	fstpl	(%esp)
				# b_arith_rel_op ( - , signed long int)
	movl	(%esp), %ecx
	addl	$8, %esp
	movl	(%esp), %eax
	subl	%ecx, %eax
	movl	%eax, (%esp)
b_convert of assign ops
				# b_convert (signed long int -> float)
	fildl	(%esp)
	fstps	(%esp)
				# b_assign (float)
	movl	(%esp), %edx
	addl	$8, %esp
	movl	(%esp), %eax
	movl	%edx, (%eax)
	movl	%edx, (%esp)
				# b_pop ()
	addl	$8, %esp
 #   47
entering make_id_expr() for id "B"
new node is a gdecl
exiting make_id_expr()
entering make_id_expr() for id "C"
new node is a gdecl
exiting make_id_expr()
making intconst
entering make_un_expr()
otherwise we return false
otherwise we return false
exiting make_un_expr()
creating a binary expression/ntype is not tyfunc or tyerror, return true
creating a deref node becuase left side l-val and not assign op
entering make_un_expr()
performing unary conversion on left and right
type is not tyfunc or tyerror, return true
performing binary conversion left and right
Binary expr: types are matches
exiting make binary express()
entering check_assign_or_proc_call()
rhs not null
creating an assignment op
creating a binary expression/ntype is not tyfunc or tyerror, return true
otherwise we return false
performing unary conversion on left and right
type is not tyfunc or tyerror, return true
performing binary conversion left and right
exiting make binary express()
				# b_push_ext_addr (B)
	subl	$8, %esp
	movl	$B, (%esp)
				# b_push_ext_addr (C)
	subl	$8, %esp
	movl	$C, (%esp)
				# b_deref (unsigned char)
	movl	(%esp), %eax
	movzbl	(%eax), %edx
	movb	%dl, (%esp)
				# b_push_const_int (34)
	movl	$34, %eax
	subl	$8, %esp
	movl	%eax, (%esp)
				# b_convert (signed long int -> unsigned char)
				# b_arith_rel_op ( < , unsigned char)
